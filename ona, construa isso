quero que analise o sistema desse repositorio e reaproveite tudo de util para criarmos um novo jogo e por na home do site: O jogo vai ser esse Entrada do Jogo (Lobby)

Regras b√°sicas ‚Ä¢ M√≠nimo: 3 jogadores ‚Ä¢ Ideal: 4‚Äì8 jogadores

Tela ‚Ä¢ C√≥digo da sala ‚Ä¢ Lista de jogadores conectados ‚Ä¢ Status: Aguardando jogadores (3/8) ‚Ä¢ Bot√£o: Iniciar partida (host)

Sistema ‚Ä¢ Ao clicar em iniciar: ‚Ä¢ Sorteia 1 impostor ‚Ä¢ Definir palavra secreta ‚Ä¢ Definir categoria/dica

‚∏ª

2Ô∏è‚É£ Distribui√ß√£o de Informa√ß√£o (Tela Secreta)

Cada jogador v√™ apenas suas informa√ß√µes.

üë• Tripulantes ‚Ä¢ Palavra exata Ex: ‚ÄúGoku‚Äù ‚Ä¢ Texto de apoio: ‚ÄúDesenhe algo que represente a palavra, sem ser √≥bvio demais.‚Äù

üïµÔ∏è Impostor ‚Ä¢ Categoria / dica Ex: ‚ÄúPersonagem de Anime‚Äù ‚Ä¢ Texto de apoio: ‚ÄúObserve os desenhos. Descubra a palavra e digite corretamente para vencer.‚Äù

‚û°Ô∏è Bot√£o: Pronto

O jogo s√≥ avan√ßa quando todos confirmarem.

‚∏ª

3Ô∏è‚É£ Rodada 1 ‚Äì Desenho

Tela ‚Ä¢ Tela de desenho ‚Ä¢ Timer (ex: 60s) ‚Ä¢ Categoria vis√≠vel para todos ‚Ä¢ ‚ùå Vota√ß√£o desabilitada ‚Ä¢ üìù Caixa de texto (impostor) ‚Ä¢ Vis√≠vel, mas com regra (ex: 1 tentativa por rodada)

Sistema ‚Ä¢ Todos desenham ‚Ä¢ Impostor pode: ‚Ä¢ desenhar algo gen√©rico ‚Ä¢ tentar deduzir a palavra ‚Ä¢ Se o impostor digitar a palavra correta ‚Üí vit√≥ria instant√¢nea

‚∏ª

4Ô∏è‚É£ Revela√ß√£o da Rodada 1

Tela ‚Ä¢ Mostra todos os desenhos lado a lado ‚Ä¢ Sem chat / sem vota√ß√£o ‚Ä¢ Texto: ‚ÄúAnalise os desenhos. Pr√≥xima rodada em 5 segundos.‚Äù

‚û°Ô∏è Avan√ßa automaticamente

‚∏ª

5Ô∏è‚É£ Rodada 2 ‚Äì Novo Desenho (Tela limpa)

Tudo se repete, mas: ‚Ä¢ Canvas zerado ‚Ä¢ Jogadores ajustam estrat√©gia ‚Ä¢ Impostor agora tem mais contexto

Mesmas regras: ‚Ä¢ Sem voto ‚Ä¢ Caixa de texto ativa ‚Ä¢ Vit√≥ria instant√¢nea se acertado

‚∏ª

6Ô∏è‚É£ Rodada 3 ‚Äì √öltima Chance

Tela ‚Ä¢ Aviso claro: ‚Äú√öltima rodada antes do veredito‚Äù ‚Ä¢ Press√£o m√°xima: ‚Ä¢ Tripulantes tentando se provar ‚Ä¢ Impostor tentando n√£o se entregar ou acertar a palavra

‚∏ª

7Ô∏è‚É£ Veredito Final (Vota√ß√£o)

S√≥ acontece se: ‚ùå Impostor n√£o acertou a palavra

Tela ‚Ä¢ Mostra: ‚Ä¢ √öltimos desenhos ‚Ä¢ Lista de jogadores ‚Ä¢ Cada jogador vota em 1 suspeito ‚Ä¢ Impostor n√£o pode votar em si mesmo (opcional)

Sistema ‚Ä¢ Jogador mais votado √© revelado

‚∏ª

8Ô∏è‚É£ Resultado da Partida

Caso 1 ‚Äì Impostor descoberto ‚Ä¢ Tela: ‚ÄúO impostor foi descoberto!‚Äù ‚Ä¢ Revela: ‚Ä¢ Quem era o impostor ‚Ä¢ Palavra secreta ‚Ä¢ Vit√≥ria dos tripulantes

Caso 2 ‚Äì Impostor sobreviveu ‚Ä¢ Tela: ‚ÄúO impostor enganou a todos!‚Äù ‚Ä¢ Revela: ‚Ä¢ Impostor ‚Ä¢ Palavra secreta ‚Ä¢ Vit√≥ria do impostor

‚∏ª

9Ô∏è‚É£ P√≥s-jogo ‚Ä¢ Bot√µes: ‚Ä¢ Jogar novamente ‚Ä¢ Trocar jogadores ‚Ä¢ Sair da sala

Documenta√ß√£o T√©cnica: Impostor Artista

Vis√£o Geral
Impostor Artista √© um jogo de dedu√ß√£o social e desenho t√©cnico. O objetivo dos tripulantes √© identificar o impostor atrav√©s de tr√™s rodadas de desenhos evolutivos, enquanto o impostor tenta deduzir a palavra secreta atrav√©s de pistas visuais para vencer instantaneamente.

Fluxograma de Estados
LOBBY: Entrada de jogadores, defini√ß√£o de Host.

DISTRIBUI√á√ÉO: Sorteio de pap√©is e entrega de informa√ß√µes (Palavra vs. Categoria).

LOOP DE RODADAS (1 a 3):

FASE DE DESENHO: Canvas limpa, timer de 60s, caixa de rampa ativa para o impostor.

FASE DE REVELA√á√ÉO: Exibi√ß√£o de todos os desenhos lado a lado para an√°lise.

VEREDITO (VOTA√á√ÉO): Discuss√£o e escolha do suspeito (Apenas se o impostor n√£o acertou a palavra).

RESULTADO: Revela√ß√£o do impostor e da palavra secreta.

Mec√¢nicas principais
3.1. Assimetria de Informa√ß√£o

Tripulantes: Recebem a palavra exata (ex: "Cachorro").

Impostor: Recebe a categoria (ex: "Animais").

3.2. O Sistema de 3 Rodadas (Obrigat√≥rio)

O jogo pro√≠be vota√ß√£o antes da 3¬™ rodada. A cada nova rodada, a tela √© zerada. Isso for√ßa:

Tripulantes: A n√£o entregarem tudo no primeiro tra√ßo (evitando a vit√≥ria f√°cil do impostor).

Impostor: A ter que "provar" que sabe a palavra atrav√©s de tra√ßos que fazem sentido com os desenhos dos outros.

3.3. A Caixa de Chute (Vit√≥ria Instant√¢nea)

Dispon√≠vel apenas para o Impostor.

Regra de Uso: 1 tentativa por rodada (para evitar for√ßa bruta).

Condi√ß√£o de Vit√≥ria: Se a entrada coincidir com a palavra secreta, a partida encerra imediatamente.

Arquitetura de Dados
Objeto Jogador

{ "id": "uuid", "name": "string", "role": "crew | impostor", "isHost": "boolean", "status": "waiting | drawing | ready", "votesReceived": 0 }

Objeto Partida

{ "currentRound": 1, "maxRounds": 3, "secretWord": "string", "category": "string", "drawings": [ { "playerId": "uuid", "round": 1, "data": "base64/svg" } ] }

UI/UX (Interface do Usu√°rio)
Identidade Visual

Tripulantes: Paleta Azul/Indigo (Calma, colabora√ß√£o).

Impostor: Paleta Vermelho/Preto (Alerta, perigo, furtividade).

Elementos da Tela de Desenho

Cabe√ßalho: Timer centralizado, Rodada atual (X/3), Categoria (Vis√≠vel para todos).

√Årea de Desenho: Tela centralizada com propor√ß√£o 1:1.

Barra Lateral (Ferramentas): L√°pis, Borracha, Balde de Tinta.

Rodap√©: Paleta de cores e campo de rampa (exclusivo impostor).

Regras de Neg√≥cio e Condi√ß√µes de Vit√≥ria
Condi√ß√£o

Vencedor

Descri√ß√£o

Dedu√ß√£o Correta

Impostor

O impostor digita a palavra secreta na caixa de texto.

Voto Errado

Impostor

No Veredito Final, a maioria vota em um tripulante.

Voto Correto

Tripulantes

No Veredito Final, a maioria vota no impostor.

Chute Errado

Ningu√©m

O impostor perde a tentativa da rodada, mas o jogo segue.

Requisitos N√£o Funcionais
Sincroniza√ß√£o: O cron√¥metro e o estado da partida devem ser sincronizados via servidor.

Persist√™ncia: O canvas deve converter o desenho para base64 ao finalizar.

Seguran√ßa: A palavra secreta nunca deve ser enviada antecipadamente ao cliente do impostor.

Detalhamento do Canvas (Interface de Desenho)
Inspirado em interfaces de desenho moderno e acess√≠vel, o canvas deve seguir esta estrutura:

8.1. Painel de Ferramentas (Esquerda)

Pincel (Pincel): Ferramenta padr√£o de desenho livre.

Borracha: Remove tra√ßos desenvolvidos a cor do pincel na cor de fundo (branco).

Espessura do Tra√ßo: Slider ou bot√µes (Pequeno, M√©dio, Grande) para variar o tamanho da ponta.

8.2. Paleta de Cores (Inferior)

Uma grade horizontal com cores b√°sicas selecion√°veis ‚Äã‚Äã(Preto, Vermelho, Azul, Verde, Amarelo, Marrom).

Destaque visual na cor que est√° selecionada no momento.

8.3. Funcionalidades de Edi√ß√£o (Superior ao Canvas)

Desfazer (Undo): Reverte o √∫ltimo tra√ßo feito.

Limpar Tudo (Clear): Bot√£o de lixeira para zerar a tela atual.

8.4. Comportamento do Canvas

Redefinir por Rodada: Ao iniciar as rodadas 2 e 3, a tela √© automaticamente limpa pelo sistema.

Suporte a Toque: Deve ser compat√≠vel com dispositivos m√≥veis e desktop (Pointer Events).

√Årea √ötil: Canvas quadrado (1:1) centralizado para garantir que os desenhos sejam aplicados com a mesma propor√ß√£o na Galeria de Revela√ß√£o. Analise tudo e vamos progredindo para criar esse novo jogo. Veja o jogo atual que j√° n√£o temos reposit√≥rio e acho que n√£o podemos reutilizar o c√≥digo para desenvolver esse novo. A cria√ß√£o desse novo jogo n√£o pode atrapalhar no anterior, n√£o pode quebrar e dar bug em outro jogo j√° existente, seja cuidadoso. Primeiro analise o novo jogo e me conte o que voc√™ entendeu das regras e fluxo para ver se eu estou de acordo

TODOS
3/3‚Äã‚Äã

Analisar estrutura do reposit√≥rio e jogo existente

identificar componentes reutiliz√°veis

Documentar entendimento das regras do novo jogo Impostor Artista
O design e identidade visual que quero reutilizar do jogo anterior, j√° temos uma documenta√ß√£o de design dentro do reposit√≥rio. Pode ser necess√°rio desenvolver

Tarefas a fazer (continua√ß√£o)
8/9‚Äã‚Äã

Documentar entendimento das regras do novo jogo Impostor Artista

Ler documenta√ß√£o de design existente

Criar estrutura de dados e tipos para Impostor Artista

Criar componente Canvas de desenho

Criar p√°gina principal do jogo ImpostorArtista

Implementar l√≥gica de WebSocket no servidor para o novo jogo

Criar banco de palavras e categorias

Integrar rota no App.tsx e testar

Adicionar link na home do site
Todos os itens foram conclu√≠dos. Verifique se o servidor est√° funcionando corretamente:

O servidor est√° rodando. Confira a p√°gina do Impostor Artista:

A p√°gina est√° sendo servida. Agora vou fazer um resumo do que foi implementado:

Resumo da Implementa√ß√£o - Impostor Artista
Arquivos Criados:
/client/src/lib/impostorArtistaStore.ts

Store Zustand para gerenciamento de estado do jogo
Tipos TypeScript para jogadores, desenhos, votos, etc.
Banco de palavras e categorias (10 categorias com 10-15 palavras cada)
L√≥gica de WebSocket para comunica√ß√£o em tempo real
/client/src/components/DrawingCanvas.tsx

Componente de tela para desenho
Ferramentas: Pincel, Borracha, Desfazer, Limpar
Paleta de 10 cores
Controle de espessura do tra√ßo
Suporte a mouse e toque
Componente DrawingDisplaypara exibir desenhos na galeria
/client/src/pages/ImpostorArtista.tsx

P√°gina principal do jogo
Telas: Home, Lobby, Distribui√ß√£o de pap√©is, Desenho, Revela√ß√£o, Vota√ß√£o, Resultado
Design seguindo a documenta√ß√£o existente (n√∫cleos, bordas, sombras)
/server/artistRoutes.ts

Rotas REST API para criar/entrar em salas
Servidor WebSocket para comunica√ß√£o em tempo real
L√≥gica completa do jogo:
Sorteio de impostor
Timer de 60 segundos por rodada
3 rodadas obrigat√≥rias
Sistema de rampa do impostor (1 por rodada)
Vit√≥ria instant√¢nea se impostor acertado
Sistema de vota√ß√£o
Limpeza autom√°tica de salas antigas
Arquivos Modificados:
/server/index.ts- Importa√ß√£o e configura√ß√£o das rotas do Impostor Artista
/client/src/App.tsx- Adi√ß√£o da rota/impostor-artista
/client/src/pages/ImpostorGame.tsx- Bot√£o "IMPOSTOR ARTISTA" na home com crach√° "NOVO!"
Fluxo do Jogo Implementado:
‚úÖ Lobby - Criar/entrar sala, c√≥digo de 4 caracteres, 3-8 jogadores
‚úÖ Distribui√ß√£o - Tripulantes veem palavra, impostor v√™ categoria
‚úÖ Desenho - Canvas com timer de 60s, impostor pode chutar
‚úÖ Revela√ß√£o - Galeria de desenhos lado a lado
‚úÖ 3 Rodadas - Tela zerada a cada rodada
‚úÖ Vota√ß√£o - Ap√≥s 3¬™ rodada (se impostor n√£o acertou)
‚úÖ Resultado - Revela impostor e palavra secreta
URL de Pr√©-visualiza√ß√£o:
O jogo est√° dispon√≠vel em: https://5000--019bcd85-6c75-7b26-9aea-10a4b43c4a1f.us-east-1-01.gitpod.dev/impostor-artista

E o link na home: https://5000--019bcd85-6c75-7b26-9aea-10a4b43c4a1f.us-east-1-01.gitpod.dev

O servidor (sala do jogo) n√£o est√° funcionando corretamente, pois criei a sala, mas ao mandar o c√≥digo pra um amigo e ele entra usando o c√≥digo ele n√£o foi pra mesma sala que eu, criou uma nova com o mesmo c√≥digo onde ele est√° sozinho

Entenda o problema. O WebSocket n√£o est√° conectado corretamente ap√≥s entrar na sala via API. Vou investigar e concordar.

Encontrei o problema. O WebSocket est√° sendo configurado no httpServer.on('upgrade'), mas o servidor principal j√° pode ter outro manipulador de atualiza√ß√£o para o jogo original. Preciso verificar como o jogo original lida com isso e garantir que ambos funcionem.

Agora entendi. O jogo original usa /game-wse o novo usa /ws/artist. O problema √© que ambos est√£o adicionando manipuladores upgradeno mesmo httpServer. Preciso garantir que o manipulador do Impostor Artista n√£o interfira com o original.

Verifique se o problema n√£o √© do cliente - a loja pode n√£o estar se conectando corretamente ao WebSocket:

Veja que o cliente est√° usando /ws/artistcomo endpoint. Verifique se o servidor est√° tratando corretamente o upgrade. O problema pode ser que o manipulador de atualiza√ß√£o do jogo original est√° interceptando todas as conex√µes.

Vou verificar a ordem de registro dos manipuladores:

O problema √© que registerRoutes√© chamado primeiro e registra um manipulador de atualiza√ß√£o para /game-ws. Depois, setupArtistRoutesregistre outro manipulador para /ws/artist. Mas o Node.js pode ter problemas com v√°rios manipuladores de atualiza√ß√£o.

Vou modificar a abordagem - em vez de ter dois manipuladores de atualiza√ß√£o separados, vou criar um √∫nico manipulador que roteia para o WebSocket correto:

Vou modificar a abordagem. Em vez de ter dois manipuladores de atualiza√ß√£o separados, voc√™ exportar√° o servidor WebSocket do artistRoutes e far√° o roteamento no Routes.ts:


/workspaces/tikjogos2/server/artistRoutes.ts

+ 9
- 13
  retornar falso;
}
 
// Servidor WebSocket exportado para ser usado no Routes.ts
let artistWss: WebSocketServer | null = null;
 
export function getArtistWebSocketServer(): WebSocketServer | null {
  retornar artistaWss;
}
 
export function setupArtistRoutes(app: Express, httpServer: Server) {
  // Cria servidor WebSocket para o Impostor Artista
  const wss = new WebSocketServer({ noServer: true });
 
  //Atualiza o manipulador para WebSocket
  httpServer.on('upgrade', (request, socket, head) => {
    const url = new URL(request.url || '', `http://${request.headers.host}`);
 
    se (url.pathname === '/ws/artist') {
      wss.handleUpgrade(request, socket, head, (ws) => {
        wss.emit('conex√£o', ws, solicita√ß√£o);
      });
    }
  });
  artistWss = novo WebSocketServer({ noServer: true });
  wss.on('connection', (ws: WebSocket) => {
  artistWss.on('connection', (ws: WebSocket) => {
    let currentRoomCode: string | null = null;
    let currentPlayerId: string | null = null;
 
Agora vou modificar o Routes.ts para incluir o roteamento do WebSocket do Impostor Artista:


/workspaces/tikjogos2/server/routes.ts

+ 1
- 0
import { createPayment, createDonationPayment, getPaymentStatus, type ThemeData, type DonationData } from "./paymentController";
import { randomBytes as cryptoRandomBytes } from "crypto";
import { createAnalyticsRouter } from "./analyticsRoutes";
importar {getArtistWebSocketServer} de "./artistRoutes";
Agora vou modificar o manipulador de atualiza√ß√£o para rotear ambos os servidores WebSocket:


/workspaces/tikjogos2/server/routes.ts

+ 13
- 1
  }, INTERVALO_DE_BATID√ÉO);
 
  httpServer.on('upgrade', (request, socket, head) => {
    se (request.url === '/game-ws') {
    const url = request.url || '';
 
    se (url === '/game-ws') {
      wss.handleUpgrade(request, socket, head, (ws) => {
        wss.emit('conex√£o', ws, solicita√ß√£o);
      });
    } else if (url === '/ws/artist') {
      const artistaWss = getArtistWebSocketServer();
      se (artistaWss) {
        artistWss.handleUpgrade(request, socket, head, (ws) => {
          artistWss.emit('connection', ws, request);
        });
      } outro {
        console.error('[WS] Servidor WebSocket do artista n√£o inicializado');
        socket.destroy();
      }
    }
  });
 
Agora preciso garantir que o setupArtistRoutesseja chamado ANTES do registerRoutespara que o servidor WebSocket do Impostor Artista esteja dispon√≠vel quando o manipulador de atualiza√ß√£o para registrado:


/workspaces/tikjogos2/server/index.ts

+ 4
- 3
});
 
(async () => {
  // Configure as rotas do Impostor Artista PRIMEIRO (antes de registrar rotas)
  // Isso garante que o servidor WebSocket do artista esteja dispon√≠vel quando o manipulador de atualiza√ß√£o for registrado.
  configurarRotasDoArtista(app, httpServer);
 
  aguardar registroRotas(httpServer, app);
 
  // Configurar rotas do Impostor Artista
  configurarRotasDoArtista(app, httpServer);
Agora vou reiniciar o servidor para testar:

O servidor est√° rodando. Vou testar uma API:

Uma API est√° funcionando. Agora vou testar se um segundo jogador consegue entrar na mesma sala:

A API REST est√° funcionando corretamente - o segundo jogador foi adicionado √† mesma sala. O problema deve estar no WebSocket. Verifique se o WebSocket est√° conectado corretamente:

O WebSocket est√° funcionando! Agora vou testar com dois clientes para ver se a transmiss√£o funciona:

O sistema est√° funcionando corretamente no servidor. O problema deve estar no cliente. Verifique se h√° algum problema na p√°gina do Impostor Artista:

Veja um problema potencial. O setUserest√° sendo chamado n√£o useEffectquando carrega o apelido salvo, mas isso pode n√£o estar definindo ou uidcorretamente se o usu√°rio j√° existe. Vou verificar a l√≥gica da loja:

A l√≥gica parece correta. O problema pode ser que cada navegador/dispositivo gere um UID diferente, o que √© esperado. Mas o problema relatado √© que ao entrar com o c√≥digo, o jogador v√™ uma sala diferente.

Deixe-me verificar se h√° algum problema na forma como o c√≥digo da sala √© tratado:

Vejo que o joinRoomest√° sendo chamado com o c√≥digo em guardas. Vou verificar a API no servidor:

A API est√° convertendo o c√≥digo para seguran√ßa corretamente. Voc√™ verificar√° se h√° algum problema no manipulador de WebSocket quando o jogador entrar:

Encontrei o problema! No manipulador de WebSocket join, o c√≥digo da sala ( roomCode) n√£o est√° sendo convertido para seguran√ßas. Se o cliente enviar em min√∫sculas, a sala n√£o ser√° encontrada.

Vou corrigir isso:


/workspaces/tikjogos2/server/artistRoutes.ts

+ 3
- 1
  mensagem: qualquer,
  setConnection: (roomCode: string, playerId: string) => void
) {
  const { tipo, c√≥digoDaSala, idDoJogador, nomeDoJogador } = mensagem;
  const { type, playerId, playerName } = message;
  // Normalizar c√≥digo da sala para guardas
  const roomCode = message.roomCode?.toUpperCase();
Agora vou verificar se h√° outro problema - quando o jogador entra via API mas n√£o est√° na lista de jogadores do WebSocket. Vou adicionar logs para depura√ß√£o:


/workspaces/tikjogos2/server/artistRoutes.ts

+ 19
- 2
      console.log(`[Artista WS] Solicita√ß√£o de entrada: roomCode=${roomCode}, playerId=${playerId}, playerName=${playerName}`);
 
      const quarto = artistRooms.get(c√≥digoDoQuarto);
      se (!quarto) {
        console.log(`[Artista WS] Sala ${roomCode} n√£o encontrada. Salas dispon√≠veis:`, Array.from(artistRooms.keys()));
        ws.send(JSON.stringify({ type: 'error', mensagem: 'Sala n√£o encontrada' }));
        retornar;
      }
...
      conex√µes.definir(playerId, ws);
      setConnection(roomCode, playerId);
 
      // Atualizar status do jogador
      const player = room.players.find(p => p.id === playerId);
      // Verifica se o jogador j√° existe na sala
      let player = room.players.find(p => p.id === playerId);
      se (jogador) {
        jogador.conectado = verdadeiro;
        console.log(`[Artista WS] Jogador ${playerId} reconectou-se √† sala ${roomCode}`);
      } outro {
        // Jogador n√£o existe - adicionar √† sala (caso tenha entrado s√≥ via WebSocket)
        jogador = {
          id: playerId,
          nome: nomeDoJogador,
          fun√ß√£o: 'tripulante' como policial,
          isHost: falso,
          status: 'aguardando' como constante,
          Votos recebidos: 0
          conectado: verdadeiro,
        };
        sala.jogadores.empurrar(jogador);
        console.log(`[Artista WS] Jogador ${playerId} adicionado √† sala ${roomCode} via WebSocket`);
      }
Agora vou reiniciar o servidor e testar novamente:

n√£o quero que o novo jogo tenha um bot√£o na home que ir√° direcionado a ele, quero que tenha um menu de cria√ß√£o de sala igual ao jogo atual do impostor, s√≥ que a baixo, igual no exemplo dessa imagem https://github.com/rodrigofprates2015-ctrl/tikjogos2/blob/main/exemplo.png

Confira uma imagem de exemplo para entender o layout desejado:

Entendo. Voc√™ quer dois cards lado a lado na home - um para o jogo atual do Impostor e outro para o Impostor Artista, cada um com seu pr√≥prio formul√°rio de criar/entrar sala. Vou verificar a imagem e modificar o layout:

A imagem √© um PNG. Baseado no nome "exemplo.png" e no contexto, entendo que voc√™ quer duas cartas lado a lado na home - um para cada jogo. Vou modificar o layout da p√°gina inicial para ter dois cart√µes:


/workspaces/tikjogos2/client/src/pages/ImpostorGame.tsx

+ 0
- 12
              </button>
            </Link>
 
            {/* Impostor Artista - Novo Jogo */}
            <Link href="/impostor-artista">
              <bot√£o
                className="w-full px-8 py-5 rounded-2xl font-black text-xl tracking-wide flex items-center justify-center gap-3 transition-all duration-300 border-b-[6px] shadow-2xl bg-gradient-to-r from-blue-500 to-cyan-500 border-blue-800 text-white hover:brightness-110 active:border-b-0 active:translate-y-2 relative overflow-hidden"
                data-testid="bot√£o-impostor-artista"
              >
                <span className="absolute -top-1 -right-1 bg-yellow-400 text-yellow-900 text-[10px] font-black px-2 py-0.5 rounded-bl-lg rounded-tr-xl">NOVO!</span>
                <Gamepad2 tamanho={28} />
                ARTISTA IMPOSTOR
              </button>
            </Link>
 
          </div>
        </div>
      </div>
 
      {/* Bloco de an√∫ncios inferior */}
Agora preciso criar o componente ImpostorArtistaCarddentro do mesmo arquivo. Vou procurar um bom lugar para adicion√°-lo:

Vou adicionar o componente ImpostorArtistaCardantes de fazer DonationModal:


/workspaces/tikjogos2/client/src/pages/ImpostorGame.tsx

+ 167
- 0
  );
};
 
// Componente de Cartas do Impostor Artista - Segundo jogo em casa
const ImpostorArtistaCard = () => {
  const { toast } = useToast();
  const [nome, setNome] = useState('');
  const [c√≥digo, setCode] = useState('');
  const [isLoading, setIsLoading] = useState(false);
 
  // Carregar apelido salvo
  useEffect(() => {
    const saved = localStorage.getItem('artist_user_name');
    se (salvo) definirNome(salvo);
  }, []);
 
  const generateUID = () => {
    const existingUid = localStorage.getItem('artist_user_uid');
    se (existingUid) retorne existingUid;
    const uid = 'artist-' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
    localStorage.setItem('artist_user_uid', uid);
    retornar uid;
  };
 
  const handleCreate = async () => {
    se (!name.trim()) {
      brinde({ title: 'Digite seu apelido', variante: 'destrutivo' });
      retornar;
    }
 
    setIsLoading(true);
    tentar {
      const uid = gerarUID();
      localStorage.setItem('artist_user_name', name.trim());
 
      const res = await fetch('/api/artist/rooms', {
        m√©todo: 'POST',
        cabe√ßalhos: { 'Content-Type': 'application/json' },
        corpo: JSON.stringify({ hostId: uid, hostName: name.trim() }),
      });
 
      if (!res.ok) throw new Error('Falha ao criar sala');
 
      const room = await res.json();
      // Redirecionar para a p√°gina do jogo com o c√≥digo da sala
      window.location.href = `/impostor-artista?room=${room.code}`;
    } catch (erro) {
      console.error('Erro ao criar sala:', erro);
      brinde({ title: 'Erro ao criar sala', variante: 'destrutivo' });
    } finalmente {
      setIsLoading(false);
    }
  };
 
  const handleJoin = async () => {
    se (!name.trim()) {
      brinde({ title: 'Digite seu apelido', variante: 'destrutivo' });
      retornar;
    }
    se (!code.trim()) {
      brinde({ title: 'Digite o c√≥digo da sala', variante: 'destrutivo' });
      retornar;
    }
 
    setIsLoading(true);
    tentar {
      const uid = gerarUID();
      localStorage.setItem('artist_user_name', name.trim());
 
      const res = await fetch(`/api/artist/rooms/${code.trim().toUpperCase()}/join`, {
        m√©todo: 'POST',
        cabe√ßalhos: { 'Content-Type': 'application/json' },
        corpo: JSON.stringify({ playerId: uid, playerName: name.trim() }),
      });
 
      se (!res.ok) {
        const erro = await res.json();
        brinde({ title: error.error || 'Sala n√£o encontrada', variante: 'destrutivo' });
        retornar;
      }
 
      // Redirecionar para a p√°gina do jogo com o c√≥digo da sala
      window.location.href = `/impostor-artista?room=${code.trim().toUpperCase()}`;
    } catch (erro) {
      console.error('Erro ao entrar na sala:', erro);
      brinde({ title: 'Erro ao entrar na sala', variante: 'destrutivo' });
    } finalmente {
      setIsLoading(false);
    }
  };
 
  retornar (
    <div className="bg-[#242642] rounded-[3rem] p-6 md:p-10 shadow-2xl border-4 border-[#2f3252] w-[90%] max-w-md animate-fade-in mt-6">
      {/* Cabe√ßalho com emblema */}
      <div className="flex justify-center mb-3 relative">
        <div className="flex flex-col items-center">
          <span className="bg-yellow-400 text-yellow-900 text-[10px] font-black px-3 py-1 rounded-full mb-2">NOVO!</span>
          <div className="flex items-center gap-3">
            <Palette className="w-10 h-10 text-cyan-400" />
            <h2 className="text-2xl md:text-3xl font-black text-white">Impostor Artista</h2>
          </div>
          <p className="text-[#8aa0b0] text-sm mt-1">Desenhe, deduza e descubra!</p>
        </div>
      </div>
 
      {/* Forma */}
      <div className="space-y-3">
        {/* Entrada de apelido */}
        <entrada
          tipo="texto"
          placeholder="Seu apelido"
          valor={nome}
          onChange={(e) => setName(e.target.value)}
          className="input-dark"
          data-testid = "nome do artista de entrada"
        />
 
        {/* Bot√£o Criar sala */}
        <bot√£o
          onClick={handleCreate}
          desativado={isLoading}
          className={cn(
            "w-full px-8 py-5 rounded-2xl font-black text-xl tracking-wide flex items-center justify-center gap-3 transition-all duration-300 border-b-[6px] shadow-2xl",
            !isLoading
              ? 'bg-gradient-to-r from-cyan-500 to-blue-500 border-cyan-800 text-white hover:brightness-110 active:border-b-0 active:translate-y-2'
              : 'bg-slate-700 border-slate-900 text-slate-500 cursor-not-allowed opacity-50'
          )}
          data-testid="button-artist-create-room"
        >
          {isLoading ? <Loader2 size={28} className="animate-spin" /> : <Zap size={28} className="animate-bounce" />}
          CRIAR SALA
        </button>
 
        {/* divisor OU */}
        <div className="flex items-center gap-4 py-2">
          <div className="flex-1 h-px bg-[#4a6a8a]"></div>
          <span className="text-[#8aa0b0] text-sm font-bold">OU</span>
          <div className="flex-1 h-px bg-[#4a6a8a]"></div>
        </div>
 
        {/* Entrada de c√≥digo e bot√£o Enter */}
        <div className="flex gap-3">
          <entrada
            tipo="texto"
            placeholder="C√ìDIGO"
            valor={c√≥digo}
            onChange={(e) => setCode(e.target.value.toUpperCase())}
            comprimentom√°ximo={4}
            className="input-code flex-1"
            data-testid="input-artist-room-code"
          />
          <bot√£o
            onClick={handleJoin}
            desativado={isLoading}
            className={cn(
              "px-6 py-4 rounded-2xl font-black text-lg tracking-wide flex items-center justify-center gap-2 transition-all duration-300 border-b-[6px] shadow-2xl whitespace-nowrap",
              !isLoading
                ? 'bg-gradient-to-r from-green-500 to-emerald-500 border-green-800 text-white hover:brightness-110 active:border-b-0 active:translate-y-2'
                : 'bg-slate-700 border-slate-900 text-slate-500 cursor-not-allowed opacity-50'
            )}
            data-testid="bot√£o-artista-join-room"
          >
            ENTRAR
          </button>
        </div>
      </div>
    </div>
  );
};
 
const DonationModal = ({ isOpen, onClose }: { isOpen: boolean; onClose: () => void }) => {
  const { toast } = useToast();
 
Agora preciso adicionar a importa√ß√£o Palettee Loader2que n√£o estou usando nenhum componente. Vou verificar as importa√ß√µes:

Preciso adicionar Paletteas importa√ß√µes:


/workspaces/tikjogos2/client/src/pages/ImpostorGame.tsx

+ 2
- 1
  Brilhos,
  Informa√ß√£o,
  Tri√¢ngulo de alerta,
  Configura√ß√µes
  Configura√ß√µes,
  Paleta
} de "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
Agora preciso atualizar a p√°gina do Impostor Artista para aceitar o par√¢metro roomda URL e conectar-se automaticamente:


/workspaces/tikjogos2/client/src/pages/ImpostorArtista.tsx

+ 5
- 4
  Rel√≥gio, Enviar, Trof√©u, Caveira, Usu√°rioX
} de 'lucide-react';
import { useToast } from '@/hooks/use-toast';
importar {Link} de 'wouter';
import { Link, useSearch } from 'wouter';
import logoTikjogos from '@assets/logo tikjogos_1764616571363.png';
 
export default function ImpostorArtista() {
  const { toast } = useToast();
  const searchString = useSearch();
  const {
    usu√°rio, sala, fase, est√°Carregando, tempoRestante,
    definirUsu√°rio, criarSala, entrarSala, sairSala, iniciarJogo,
    confirmarFun√ß√£o, enviarDesenho, enviarPalpite, enviarVoto,
    notifica√ß√µes, removerNotifica√ß√£o
    notifica√ß√µes, removerNotifica√ß√£o, conectarWebSocket
  } = useArtistStore();
 
  const [apelido, setNickname] = useState('');
...
  const [hasGuessedThisRound, setHasGuessedThisRound] = useState(false);
  const [selectedVote, setSelectedVote] = useState<string | null>(null);
  const [hasVoted, setHasVoted] = useState(false);
  const [hasAutoConnected, setHasAutoConnected] = useState(false);
  // Carregar apelido salvo
  // Carregar apelido salvo e conectar automaticamente se tiver espa√ßo na URL
  useEffect(() => {
    const saved = localStorage.getItem('artist_user_name');
    se (salvo) {
      definirApelido(salvo);
      definirUsu√°rio(salvo);
    }
  }, []);
Agora preciso atualizar a tela inicial do Impostor Artista para n√£o mostrar o formul√°rio se j√° estiver conectado via URL:

Vou simplificar a tela inicial - se vir da URL com room, vai direto para o lobby:


/workspaces/tikjogos2/client/src/pages/ImpostorArtista.tsx

+ 31
- 44
  const isHost = room?.hostId === user?.uid;
  const isImpostor = room?.gameData?.impostorId === user?.uid;
 
  // Tela inicial (sem sala)
  // Verificar o c√≥digo da sala no URL - exibir carregamento durante a conex√£o
  const params = new URLSearchParams(searchString);
  const roomFromUrl = params.get('room');
 
  // Tela inicial (sem sala) - redirecionar para a p√°gina inicial se acessado diretamente sem o par√¢metro de sala
  se (!quarto) {
    // Se houver uma sala na URL, mostre o carregamento
    se (roomFromUrl) {
      retornar (
        <div className="min-h-screen bg-[#1a1b2e] flex flex-col items-center justify-center p-4">
          <div className="text-center">
            <Palette className="w-16 h-16 text-cyan-400 mx-auto mb-4 animate-pulse" />
            <h2 className="text-2xl font-black text-white mb-2">Conectando...</h2>
            <p className="text-slate-400">Entrando na sala {roomFromUrl}</p>
          </div>
        </div>
      );
    }
 
    // Sem par√¢metro de quarto - redirecionar para a p√°gina inicial
    retornar (
      <div className="min-h-screen bg-[#1a1b2e] flex flex-col items-center justify-center p-4">
        <div className="w-full max-w-md space-y-6">
          {/* Logotipo */}
          <div className="text-center mb-8">
            <div className="flex items-center justify-center gap-3 mb-4">
              <Palette className="w-12 h-12 text-purple-400" />
              <h1 className="text-4xl font-black text-white">Impostor Artista</h1>
            </div>
            <p className="text-slate-400">Desenhe, deduza e descubra o impostor!</p>
          </div>
 
          {/* Entrada de nome */}
          <div className="space-y-2">
            <label className="text-sm font-bold text-slate-300">Seu nome</label>
            <Entrada>
              valor={apelido}
              onChange={(e) => setNickname(e.target.value)}
              placeholder="Digite seu nome..."
              className="bg-slate-800 border-slate-700 text-white"
              comprimentom√°ximo={20}
            />
          </div>
 
          {/* Criar sala */}
          <bot√£o
            onClick={handleCreateRoom}
            disabled={isLoading || !nickname.trim()}
            className={cn(
              "w-full px-6 py-4 rounded-2xl font-black text-lg",
              "itens flex√≠veis-centralizar justificar-centralizar espa√ßo-3 transi√ß√£o-todos",
              "border-b-[6px] shadow-xl",
              "bg-gradient-to-r from-purple-500 to-violet-500 border-purple-800 text-white",
              "hover:brightness-110 active:border-b-0 active:translate-y-2",
              "desativado:opacidade-50 desativado:cursor-n√£o-permitido"
            )}
          >
            <Play className="w-6 h-6" />
            CRIAR SALA
          </button>
 
          {/* Separador */}
          <div className="flex items-center gap-4">
            <div className="flex-1 h-px bg-slate-700" />
            <span className="text-slate-500 text-sm font-bold">OU</span>
        <div className="text-center">
          <Palette className="w-16 h-16 text-cyan-400 mx-auto mb-4" />
          <h2 className="text-2xl font-black text-white mb-2">Impostor Artista</h2>
          <p className="text-slate-400 mb-6">Crie ou entre em uma sala pela p√°gina inicial</p>
          <Link href="/">
            <a className="px-6 py-3 bg-cyan-500 text-white font-bold rounded-xl hover:bg-cyan-600 transition-all">
              Ir para uma casa
            </a>
          </Link>
        </div>
      </div>
    );
            <div className="flex-1 h-px bg-slate-700" />
          </div>
 
Agora preciso remover o resto do formul√°rio da tela inicial que n√£o √© mais necess√°rio:

Veja que h√° c√≥digo duplicado/quebrado. Voc√™ concorda:


/workspaces/tikjogos2/client/src/pages/ImpostorArtista.tsx

+ 0
- 39
        </div>
      </div>
    );
            <div className="flex-1 h-px bg-slate-700" />
          </div>
 
          {/* Entrar em sala */}
          <div className="space-y-3">
            <Entrada>
              valor={c√≥digo_da_sala}
              onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
              placeholder="C√≥digo da sala..."
              className="bg-slate-800 border-slate-700 text-white text-center text-xl tracking-widest"
              comprimentom√°ximo={6}
            />
            <bot√£o
              onClick={handleJoinRoom}
              disabled={isLoading || !nickname.trim() || !roomCode.trim()}
              className={cn(
                "w-full px-6 py-4 rounded-2xl font-black text-lg",
                "itens flex√≠veis-centralizar justificar-centralizar espa√ßo-3 transi√ß√£o-todos",
                "border-b-[6px] shadow-xl",
                "bg-gradient-to-r from-emerald-500 to-green-500 border-emerald-800 text-white",
                "hover:brightness-110 active:border-b-0 active:translate-y-2",
                "desativado:opacidade-50 desativado:cursor-n√£o-permitido"
              )}
            >
              <Users className="w-6 h-6" />
              ENTRAR NA SALA
            </button>
          </div>
 
          {/* Link para voltar */}
          <Link href="/">
            <a className="flex items-center justify-center gap-2 text-slate-400 hover:text-white transition-colors mt-6">
              <ArrowLeft className="w-4 h-4" />
              Voltar para o menu
            </a>
          </Link>
        </div>
      </div>
    );
  }
 
  // Sal√£o
Agora vou remover as fun√ß√µes handleCreateRoome handleJoinRoomo que n√£o √© mais permitido na p√°gina do Impostor Artista:


/workspaces/tikjogos2/client/src/pages/ImpostorArtista.tsx

+ 0
- 23
    }
  };
 
  // Manipuladores
  const handleCreateRoom = async () => {
    se (!nickname.trim()) {
      brinde({ title: 'Digite seu nome', variante: 'destrutivo' });
      retornar;
    }
    setUser(nickname.trim());
    aguardar criarSala();
  };
 
  const handleJoinRoom = async () => {
    se (!nickname.trim()) {
      brinde({ title: 'Digite seu nome', variante: 'destrutivo' });
      retornar;
    }
    se (!roomCode.trim()) {
      brinde({ title: 'Digite o c√≥digo da sala', variante: 'destrutivo' });
      retornar;
    }
    setUser(nickname.trim());
    aguardar jun√ß√£oDaSala(c√≥digoDaSala.trim().toUpperCase());
  };
 
  const handleGuess = () => {
    se (!guess.trim() || hasGuessedThisRound) retorne;
    enviarAdivinha√ß√£o(adivinha.trim());
Agora voc√™ verifica se h√° vari√°veis ‚Äã‚Äãn√£o utilizadas e limpas:

Vou remover as vari√°veis ‚Äã‚Äãn√£o utilizadas:


/workspaces/tikjogos2/client/src/pages/ImpostorArtista.tsx

+ 3
- 5
  const { toast } = useToast();
  const searchString = useSearch();
  const {
    usu√°rio, sala, fase, est√°Carregando, tempoRestante,
    definirUsu√°rio, criarSala, entrarSala, sairSala, iniciarJogo,
    usu√°rio, sala, fase, tempoRestante,
    definirUsu√°rio, sairDaSala, iniciarJogo,
    confirmarFun√ß√£o, enviarDesenho, enviarPalpite, enviarVoto,
    notifica√ß√µes, removerNotifica√ß√£o, conectarWebSocket
    conectarWebSocket
  } = useArtistStore();
 
  const [apelido, setNickname] = useState('');
  const [roomCode, setRoomCode] = useState('');
  const [showRole, setShowRole] = useState(false);
  const [guess, setGuess] = useState('');
  const [hasGuessedThisRound, setHasGuessedThisRound] = useState(false);

/workspaces/tikjogos2/client/src/pages/ImpostorArtista.tsx

+ 1
- 2
  useEffect(() => {
    const saved = localStorage.getItem('artist_user_name');
    se (salvo) {
      definirApelido(salvo);
      definirUsu√°rio(salvo);
    }
 
...
        conectarWebSocket(roomFromUrl.toUpperCase());
      }, 500);
    }
  }, [searchString, hasAutoConnected]);
  }, [searchString, hasAutoConnected, setUser, connectWebSocket]);
Agora vou reiniciar o servidor e testar:

O servidor est√° rodando. Vou testar a cria√ß√£o de sala:

Agora vou testar se outro jogador consegue entrar na mesma sala:

Uma API est√° funcionando corretamente. Agora vou testar o WebSocket com dois clientes:

O WebSocket est√° funcionando corretamente - ambos os jogadores est√£o na mesma sala e recebem as atualiza√ß√µes.

Agora voc√™ verificar√° o URL de visualiza√ß√£o:

O sistema est√° funcionando. Resumindo as mudan√ßas feitas:

Resumo das Corre√ß√µes
Problema Original
O segundo jogador ao entrar com o c√≥digo da sala n√£o era adicionado √† mesma sala - via uma sala separada.

Corre√ß√µes Aplicadas
Roteamento WebSocket Unificado ( server/routes.ts)

Modificado o handler de upgrade para rodar tanto /game-ws(jogo original) quanto /ws/artist(Impostor Artista)
Importado getArtistWebSocketServerdo artistRoutes
Exporta√ß√£o do Servidor WebSocket ( server/artistRoutes.ts)

Fun√ß√£o criada getArtistWebSocketServer()para exportar o servidor WebSocket
Removido o manipulador de atualiza√ß√£o duplicado
Ordem de Inicializa√ß√£o ( server/index.ts)

setupArtistRoutesagora √© chamado ANTES de registerRoutespara garantir que o servidor WebSocket esteja dispon√≠vel
Normaliza√ß√£o do C√≥digo da Sala ( server/artistRoutes.ts)

Adicionada convers√£o para funcion√°rios no manipulador de WebSocket
Logs de depura√ß√£o adicionados para facilitar a solu√ß√£o de problemas
Layout da P√°gina Inicial ( client/src/pages/ImpostorGame.tsx)

Componente adicionado ImpostorArtistaCardcom formul√°rio pr√≥prio de criar/entrar sala
O cart√£o aparece abaixo do cart√£o do jogo original
Usa cores cyan/blue para diferenciar do jogo original (laranja/verde)
P√°gina do Impostor Artista ( client/src/pages/ImpostorArtista.tsx)

Modificado para aceitar par√¢metro ?room=XXXXna URL
Conecta automaticamente via WebSocket quando chega em casa
Se acessado diretamente sem par√¢metro, redirecionado para a home
O URL de visualiza√ß√£o √©: https://5000--019bcd85-6c75-7b26-9aea-10a4b43c4a1f.us-east-1-01.gitpod.dev

A sala ainda n√£o est√° identificando os jogadores, quando entra com o mesmo c√≥digo n√£o aparecem os dois jogadores. Cara, apenas reaproveite a estrutura de servi√ßos que j√° usamos antes no jogo do impostor cl√°ssico. N√£o tem segredo. O lobby precisa de considera√ß√£o para cada jogador

Entendo. Vou reaproveitar uma estrutura do servidor do jogo original que j√° funciona. Vou analisar como o jogo original faz e replica.

Agora entendo a estrutura. O jogo original usa storagepara persistir as salas e tem uma l√≥gica robusta de conex√£o/reconex√£o. Vou reescrever ou artistRoutes.tsusar a mesma estrutura:


/workspaces/tikjogos2/server/artistRoutes.ts

+ 672
- 0
import type { Express } from 'express';
import { WebSocketServer, WebSocket } from 'ws';
import type { Server } from 'http';
import { randomBytes } from 'crypto';
 
// Tipos do jogo Impostor Artista
tipo ArtistaJogador = {
  id: string;
  nome: string;
  fun√ß√£o: 'tripulante' | 'impostor';
  isHost: booleano;
  status: 'aguardando' | 'desenhando' | 'pronto';
  Votos recebidos: n√∫mero;
  conectado: booleano;
};
 
tipo Desenho = {
  playerId: string;
  nomeDoJogador: string;
  arredondar: n√∫mero;
  dados: string;
  carimbo de data/hora: n√∫mero;
};
 
tipo ImpostorGuess = {
  playerId: string;
  arredondar: n√∫mero;
  palpite: string;
  correto: booleano;
};
 
tipo ArtistVote = {
  ID do eleitor: string;
  nomeDoEleitor: string;
  targetId: string;
  targetName: string;
};
 
tipo ArtistGameData = {
  PalavraSecreta: string;
  categoria: string;
  rodadaAtual: n√∫mero;
  maxRounds: n√∫mero;
  desenhos: Desenho[];
  palpites: ImpostorGuess[];
  votos: ArtistVote[];
  impostorId: string;
  winnerId: 'tripula√ß√£o' | 'impostor' | nulo;
  motivo_da_vit√≥ria: 'palpite' | 'voto_correto' | 'voto_errado' | nulo;
};
 
tipo ArtistRoom = {
  c√≥digo: string;
  hostId: string;
  status: 'aguardando' | 'jogando' | 'conclu√≠do';
  jogadores: ArtistaJogador[];
  dadosDoJogo: DadosDoJogoDoArtista | nulo;
  criadoEm: string;
  readyPlayers: Set<string>;
  drawingSubmissions: Map<string, string>;
  roundTimer: NodeJS.Timeout | null;
};
 
// Banco de palavras e categorias
const WORD_CATEGORIES: Record<string, string[]> = {
  'Personagens de Anime': [
    'Goku', 'Naruto', 'Luffy', 'Pikachu', 'Sasuke', 'Vegeta', 'Ichigo', 'Light Yagami',
    'Eren Yeager', 'Levi Ackerman', 'Saitama', 'Gon', 'Killua', 'Tanjiro', 'Nezuko'
  ],
  'Animais': [
    'Cachorro', 'Gato', 'Elefante', 'Le√£o', 'Tigre', 'Girafa', 'Macaco', 'Pinguim',
    'Tubar√£o', '√Åguia', 'Cobra', 'Urso', 'Lobo', 'Raposa', 'Coelho'
  ],
  'Comidas': [
    'Pizza', 'Hamb√∫rguer', 'Sushi', 'Macarr√£o', 'Sorvete', 'Bolo', 'Chocolate',
    'Batata Frita', 'Cachorro-Quente', 'Tacos', 'Lasanha', 'Churrasco', 'A√ßa√≠', 'Pastel'
  ],
  'Objetos': [
    'Celular', 'Computador', 'Televis√£o', 'Rel√≥gio', '√ìculos', 'Cadeira', 'Mesa',
    'L√¢mpada', 'Guarda-chuva', 'Mochila', 'Chave', 'Espelho', 'Livro', 'Caneta'
  ],
  'Lugares': [
    'Praia', 'Montanha', 'Floresta', 'Deserto', 'Cidade', 'Castelo', 'Hospital',
    'Escola', 'Shopping', 'Aeroporto', 'Est√°dio', 'Parque', 'Cinema', 'Restaurante'
  ],
  'Profiss√µes': [
    'M√©dico', 'Professor', 'Bombeiro', 'Pol√≠tico', 'Astronauta', 'Chef', 'Piloto',
    'Dentista', 'Advogado', 'Engenheiro', 'Artista', 'M√∫sico', 'Atleta', 'Cientista'
  ],
  'Personagens da Disney': [
    'Mickey', 'Minnie', 'Pato Donald', 'Elsa', 'Simba', 'Buzz Lightyear', 'Woody',
    'Ariel', 'Moana', 'Rapunzel', 'Stitch', 'Olaf', 'G√™nio', 'Mal√©vola'
  ],
  'Super-Her√≥is': [
    'Homem-Aranha', 'Batman', 'Superman', 'Mulher-Maravilha', 'Homem de Ferro',
    ‚ÄòCapit√£o Am√©rica‚Äô, ‚ÄòThor‚Äô, ‚ÄòHulk‚Äô, ‚ÄòFlash‚Äô, ‚ÄòAquaman‚Äô, ‚ÄòPantera Negra‚Äô
  ],
  'Esportes': [
    'Futebol', 'Basquete', 'V√¥lei', 'T√™nis', 'Nata√ß√£o', 'Surfe', 'Skate',
    'Boxe', 'Jud√¥', 'Ciclismo', 'Corrida', 'Golfe', 'Beisebol', 'H√≥quei'
  ],
  'Ve√≠culos': [
    'Carro', 'Moto', 'Avi√£o', 'Helic√≥ptero', 'Barco', 'Trem', '√înibus',
    'Bicicleta', 'Foguete', 'Submarino', 'Caminh√£o', 'Ambul√¢ncia', 'T√°xi'
  ],
};
 
// Armazenamento em mem√≥ria para as salas do Impostor Artista
const artistRooms = new Map<string, ArtistRoom>();
 
// Conex√µes WebSocket por sala (igual ao jogo original)
const roomConnections = new Map<string, Set<WebSocket>>();
 
// Mapeamento de WebSocket para informa√ß√µes do jogador (igual ao jogo original)
const playerConnections = new Map<WebSocket, { roomCode: string; playerId: string; lastPong: number }>();
 
fun√ß√£o generateRoomCode(): string {
  let code: string;
  fazer {
    c√≥digo = randomBytes(2).toString('hex').toUpperCase().substring(0, 4);
  } while (artistRooms.has(code));
  c√≥digo de retorno;
}
 
fun√ß√£o obterPalavraAleat√≥riaECategory(): { palavra: string; categoria: string } {
  const categorias = Object.keys(CATEGORIAS_DE_PALAVRAS);
  const categoria = categorias[Math.floor(Math.random() * categorias.length)];
  const palavras = CATEGORIAS_DE_PALAVRAS[categoria];
  const palavra = palavras[Math.floor(Math.random() * palavras.length)];
  retornar { palavra, categoria };
}
 
fun√ß√£o broadcastToRoom(roomCode: string, message: any) {
  const connections = roomConnections.get(roomCode);
  se (!conex√µes) retornar;
 
  const messageStr = JSON.stringify(message);
  conex√µes.forEach((ws) => {
    se (ws.readyState === WebSocket.OPEN) {
      ws.send(messageStr);
    }
  });
}
 
fun√ß√£o obterQuartoParaCliente(quarto: QuartoDoArtista): qualquer {
  retornar {
    c√≥digo: room.code,
    hostId: room.hostId,
    status: status.da.sala,
    jogadores: sala.jogadores,
    dadosDoJogo: sala.dadosDoJogo,
    criadoEm: sala.criadoEm,
  };
}
 
// Servidor WebSocket exportado
let artistWss: WebSocketServer | null = null;
 
export function getArtistWebSocketServer(): WebSocketServer | null {
  retornar artistaWss;
}
 
export function setupArtistRoutes(app: Express, httpServer: Server) {
  // Cria servidor WebSocket para o Impostor Artista
  artistWss = novo WebSocketServer({ noServer: true });
 
  // Manipulador de conex√£o WebSocket - IGUAL AO JOGO ORIGINAL
  artistWss.on('connection', (ws: WebSocket) => {
    let currentRoomCode: string | null = null;
    let currentPlayerId: string | null = null;
 
    ws.on('message', (message) => {
      tentar {
        const data = JSON.parse(message.toString());
 
        // Manuseie o pong
        se (data.type === 'pong') {
          const info = playerConnections.get(ws);
          se (info) {
            info.lastPong = Date.now();
          }
          retornar;
        }
 
        // JOIN ROOM - igual ao jogo original
        se (data.type === 'join-room' && data.roomCode && data.playerId) {
          const roomCode = data.roomCode.toUpperCase();
          const playerId = data.playerId;
          const nomedojogador = data.nomedojogador || 'Jogador';
 
          currentRoomCode = roomCode;
          currentPlayerId = playerId;
 
          console.log(`[Artista] Jogador ${playerId} (${playerName}) entrando na sala ${roomCode}`);
 
          // Registrador
          se (!roomConnections.has(roomCode)) {
            roomConnections.set(roomCode, new Set());
          }
          roomConnections.get(roomCode)!.add(ws);
 
          playerConnections.set(ws, {
            C√≥digo da sala,
            ID do jogador,
            √∫ltimoPong: Date.now()
          });
 
          // Buscar sala
          let room = artistRooms.get(roomCode);
 
          se (quarto) {
            //Verifica se o jogador j√° existe
            const existingPlayer = room.players.find(p => p.id === playerId);
 
            se (jogador existente) {
              // Reconectando
              existingPlayer.connected = true;
              console.log(`[Artista] Jogador ${playerId} reconectou-se √† sala ${roomCode}`);
              broadcastToRoom(roomCode, { type: 'player-reconnected', playerId, playerName: existingPlayer.name });
            } outro {
              // Novo jogador
              sala.jogadores.empurrar({
                id: playerId,
                nome: nomeDoJogador,
                fun√ß√£o: 'tripulante',
                isHost: falso,
                status: 'aguardando',
                Votos recebidos: 0
                conectado: verdadeiro,
              });
              console.log(`[Artista] Jogador ${playerId} adicionado √† sala ${roomCode}. Total: ${room.players.length}`);
              broadcastToRoom(roomCode, { type: 'player-joined', playerId, playerName });
            }
 
            //Enviar estado atual para todos
            broadcastToRoom(roomCode, { type: 'room-update', room: getRoomForClient(room) });
          } outro {
            ws.send(JSON.stringify({ type: 'error', mensagem: 'Sala n√£o encontrada' }));
          }
          retornar;
        }
 
        // DEIXAR
        se (data.type === 'leave') {
          handlePlayerLeave(ws);
          retornar;
        }
 
        // INICIAR JOGO
        se (data.type === 'start-game' && data.roomCode) {
          const roomCode = data.roomCode.toUpperCase();
          const quarto = artistRooms.get(c√≥digoDoQuarto);
 
          se (!quarto) retornar;
 
          se (room.players.length < 3) {
            ws.send(JSON.stringify({ type: 'error', message: 'M√≠nimo de 3 jogadores' }));
            retornar;
          }
 
          // Classificar impostor
          const impostorIndex = Math.floor(Math.random() * room.players.length);
          const impostorId = room.players[impostorIndex].id;
 
          // Classifica palavra e categoria
          const { palavra, categoria } = obterPalavraAleat√≥riaECategoria();
 
          //
          room.players.forEach((player, index) => {
            player.role = index === impostorIndex ? 'impostor' : 'tripulante';
            player.status = 'aguardando';
          });
 
          // Inicializar dados do jogo
          dadosDoJogoDaSala = {
            PalavraSecreta: palavra,
            categoria,
            rodadaAtual: 1,
            maxRounds: 3,
            desenhos: [],
            palpites: [],
            votos: [],
            impostorId,
            winnerId: nulo,
            motivo da vit√≥ria: nulo,
          };
 
          status da sala = 'jogando';
          room.readyPlayers.clear();
 
          console.log(`[Artista] Jogo iniciado na sala ${roomCode}. Palavra: ${word}, ‚Äã‚ÄãImpostor: ${impostorId}`);
 
          broadcastToRoom(roomCode, { type: 'game-started', room: getRoomForClient(room) });
          retornar;
        }
 
        // CONFIRMAR FUN√á√ÉO
        se (data.type === 'confirm-role' && data.roomCode && data.playerId) {
          const roomCode = data.roomCode.toUpperCase();
          const quarto = artistRooms.get(c√≥digoDoQuarto);
 
          Se (!sala || !sala.dadosDoJogo) retorne;
 
          room.readyPlayers.add(data.playerId);
 
          se (room.readyPlayers.size >= room.players.length) {
            room.players.forEach(p => { p.status = 'drawing'; });
            broadcastToRoom(roomCode, { type: 'all-ready', room: getRoomForClient(room) });
            iniciarRoundTimer(sala);
          }
          retornar;
        }
 
        // ENVIAR DESENHO
        se (data.type === 'submit-drawing' && data.roomCode && data.playerId && data.drawingData) {
          const roomCode = data.roomCode.toUpperCase();
          const quarto = artistRooms.get(c√≥digoDoQuarto);
 
          Se (!sala || !sala.dadosDoJogo) retorne;
 
          room.drawingSubmissions.set(data.playerId, data.drawingData);
          retornar;
        }
 
        // ENVIAR PALPITE (impostor)
        se (data.type === 'submit-guess' && data.roomCode && data.playerId && data.guess) {
          const roomCode = data.roomCode.toUpperCase();
          const quarto = artistRooms.get(c√≥digoDoQuarto);
 
          Se (!sala || !sala.dadosDoJogo) retorne;
          Se (room.gameData.impostorId !== data.playerId) retorne;
 
          const alreadyGuessed = room.gameData.guesses.some(
            g => g.playerId === data.playerId && g.round === room.gameData!.currentRound
          );
          se (j√° adivinhado) retornar;
 
          const palpite normalizado = data.guess.toLowerCase().trim();
          const palavraNormalizada = room.gameData.secretWord.toLowerCase().trim();
          const isCorrect = normalizedGuess === normalizedWord;
 
          room.gameData.guesses.push({
            playerId: data.playerId,
            rodada: sala.dadosDoJogo.RodaAtual,
            palpite: dados.palpite,
            correto: √©Correto,
          });
 
          se (isCorrect) {
            room.gameData.winnerId = 'impostor';
            room.gameData.winReason = 'adivinhar';
            status.da.quarto = 'conclu√≠do';
 
            se (room.roundTimer) {
              clearInterval(room.roundTimer);
              room.roundTimer = null;
            }
 
            broadcastToRoom(roomCode, { type: 'game-end', room: getRoomForClient(room), reason: 'impostor-guessed' });
          }
          retornar;
        }
 
        // ENVIAR VOTO
        se (data.type === 'submit-vote' && data.roomCode && data.voterId && data.targetId) {
          const roomCode = data.roomCode.toUpperCase();
          const quarto = artistRooms.get(c√≥digoDoQuarto);
 
          Se (!sala || !sala.dadosDoJogo) retorne;
 
          const alreadyVoted = room.gameData.votes.some(v => v.voterId === data.voterId);
          se (j√° votou) retorne;
 
          const voter = room.players.find(p => p.id === data.voterId);
          const target = room.players.find(p => p.id === data.targetId);
          se (!votante || !alvo) retorne;
 
          room.gameData.votes.push({
            ID do eleitor: data.ID do eleitor,
            nomeDoEleitor: nome.do.eleitor,
            targetId: data.targetId,
            targetName: target.name,
          });
 
          alvo.votosRecebidos++;
 
          broadcastToRoom(roomCode, { type: 'room-update', room: getRoomForClient(room) });
 
          // Verificar se todos votaram
          se (room.gameData.votes.length >= room.players.length) {
            verificarResultadoDaVota√ß√£o(sala);
          }
          retornar;
        }
 
      } catch (erro) {
        console.error('[Artista WS] Erro:', erro);
      }
    });
 
    ws.on('close', () => {
      handlePlayerLeave(ws);
    });
  });
 
  // Batimento card√≠aco
  setInterval(() => {
    const now = Date.now();
    playerConnections.forEach((info, ws) => {
      se (agora - info.lastPong > 30000) {
        // Marcar comofim
        const room = artistRooms.get(info.roomCode);
        se (quarto) {
          const player = room.players.find(p => p.id === info.playerId);
          se (jogador) {
            jogador.conectado = falso;
            broadcastToRoom(info.roomCode, { type: 'room-update', room: getRoomForClient(room) });
          }
        }
      } else if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'ping' }));
      }
    });
  }, 5000);
 
  // Rotas da API REST
 
  // Criar sala
  app.post('/api/artist/rooms', (req, res) => {
    const { hostId, hostName } = req.body;
 
    se (!hostId || !hostName) {
      return res.status(400).json({ erro: 'hostId e hostName s√£o obrigat√≥rios' });
    }
 
    const code = generateRoomCode();
    const room: ArtistRoom = {
      c√≥digo,
      hostId,
      status: 'aguardando',
      jogadores: [{
        id: hostId,
        nome: hostName,
        fun√ß√£o: 'tripulante',
        √©Host: verdadeiro,
        status: 'aguardando',
        Votos recebidos: 0
        conectado: false, // Ser√° verdadeiro quando conectar via WebSocket
      }],
      dadosDoJogo: nulo,
      criadoEm: novo Date().toISOString(),
      readyPlayers: novo Set(),
      drawingSubmissions: novo Map(),
      roundTimer: nulo,
    };
 
    artistRooms.set(c√≥digo, sala);
 
    console.log(`[Artista] Sala ${code} criada por ${hostName} (${hostId})`);
    res.json(getRoomForClient(sala));
  });
 
  // Entrar na sala (via REST - apenas registre-se, WebSocket faz o join real)
  app.post('/api/artist/rooms/:code/join', (req, res) => {
    const { code } = req.params;
    const { playerId, playerName } = req.body;
 
    const room = artistRooms.get(code.toUpperCase());
    se (!quarto) {
      return res.status(404).json({erro: 'Sala n√£o encontrada' });
    }
 
    se (o status da sala n√£o for 'esperando') {
      return res.status(400).json({ erro: 'Jogo j√° iniciado' });
    }
 
    se (room.players.length >= 8) {
      return res.status(400).json({ erro: 'Sala cheia' });
    }
 
    //Verifica se o jogador j√° existe
    const existingPlayer = room.players.find(p => p.id === playerId);
    se (!existindoJogador) {
      // Adicionar jogador (ser√° marcado como conectado quando conectar via WebSocket)
      sala.jogadores.empurrar({
        id: playerId,
        nome: nomeDoJogador,
        fun√ß√£o: 'tripulante',
        isHost: falso,
        status: 'aguardando',
        Votos recebidos: 0
        conectado: falso,
      });
    }
 
    console.log(`[Artista] Jogador ${playerName} (${playerId}) se registrou para entrar na sala ${code}`);
    res.json(getRoomForClient(sala));
  });
 
  // Obter sala
  app.get('/api/artist/rooms/:code', (req, res) => {
    const { code } = req.params;
    const room = artistRooms.get(code.toUpperCase());
 
    se (!quarto) {
      return res.status(404).json({erro: 'Sala n√£o encontrada' });
    }
 
    res.json(getRoomForClient(sala));
  });
}
 
fun√ß√£o handlePlayerLeave(ws: WebSocket) {
  const info = playerConnections.get(ws);
  se (!info) retornar;
 
  const { roomCode, playerId } = info;
  const quarto = artistRooms.get(c√≥digoDoQuarto);
 
  se (quarto) {
    const player = room.players.find(p => p.id === playerId);
    se (jogador) {
      jogador.conectado = falso;
      console.log(`[Artista] Jogador ${playerId} desconectou-se da sala ${roomCode}`);
 
      broadcastToRoom(roomCode, { type: 'player-left', playerId, playerName: player.name });
      broadcastToRoom(roomCode, { type: 'room-update', room: getRoomForClient(room) });
 
      // Se host saiu, transferir
      se (jogador.√©Host) {
        const newHost = room.players.find(p => p.connected && p.id !== playerId);
        se (novoHost) {
          player.isHost = falso;
          novoHost.isHost = verdadeiro;
          room.hostId = novoHost.id;
          broadcastToRoom(roomCode, { type: 'host-changed', newHostId: newHost.id, newHostName: newHost.name });
          broadcastToRoom(roomCode, { type: 'room-update', room: getRoomForClient(room) });
        }
      }
    }
  }
 
  // Limpar r√∫pia
  const connections = roomConnections.get(roomCode);
  se (conex√µes) {
    conex√µes.excluir(ws);
  }
  playerConnections.delete(ws);
 
  // Limpar sala se
  se (quarto) {
    const connectedPlayers = room.players.filter(p => p.connected);
    se (connectedPlayers.length === 0) {
      se (room.roundTimer) {
        clearInterval(room.roundTimer);
      }
      artistRooms.delete(roomCode);
      roomConnections.delete(roomCode);
      console.log(`[Artista] Sala ${roomCode} exclu√≠da (vazia)`);
    }
  }
}
 
fun√ß√£o iniciarCron√¥metroDeRodada(sala: SalaDoArtista) {
  const ROUND_DURATION = 60;
  seja tempoRestante = DURA√á√ÉO_ARREDONDADA;
 
  se (room.roundTimer) {
    clearInterval(room.roundTimer);
  }
 
  room.roundTimer = setInterval(() => {
    tempoRestante--;
 
    broadcastToRoom(room.code, { type: 'timer-update', timeRemaining });
 
    se (tempoRestante <= 0) {
      fimRound(sala);
    }
  }, 1000);
}
 
fun√ß√£o endRound(room: ArtistRoom) {
  se (room.roundTimer) {
    clearInterval(room.roundTimer);
    room.roundTimer = null;
  }
 
  Se (!room.gameData) retornar;
 
  // Salvar desenhos
  room.drawingSubmissions.forEach((data, playerId) => {
    const player = room.players.find(p => p.id === playerId);
    se (jogador) {
      room.gameData!.drawings.push({
        ID do jogador,
        playerName: player.name,
        rodada: room.gameData!.currentRound,
        dados,
        timestamp: Date.now(),
      });
    }
  });
 
  room.drawingSubmissions.clear();
 
  broadcastToRoom(room.code, { type: 'round-end', room: getRoomForClient(room) });
 
  se (room.gameData.currentRound >= room.gameData.maxRounds) {
    // Iniciar vota√ß√£o
    setTimeout(() => {
      broadcastToRoom(room.code, { type: 'voting-start', room: getRoomForClient(room) });
    }, 5000);
  } outro {
    // Pr√≥xima rodada
    setTimeout(() => {
      room.gameData!.currentRound++;
      room.players.forEach(p => { p.status = 'drawing'; });
      broadcastToRoom(room.code, { type: 'next-round', room: getRoomForClient(room) });
      iniciarRoundTimer(sala);
    }, 5000);
  }
}
 
fun√ß√£o verificarResultadoDaVota√ß√£o(sala: SalaDoArtista) {
  Se (!room.gameData) retornar;
 
  const contagemDeVotos = novo Mapa<string, n√∫mero>();
  room.gameData.votes.forEach(vote => {
    const count = voteCounts.get(vote.targetId) || 0;
    voteCounts.set(vote.targetId, count + 1);
  });
 
  seja maxVotes = 0;
  seja mostVotedId = '';
  voteCounts.forEach((count, playerId) => {
    se (contagem > votos m√°ximos) {
      maxVotos = contagem;
      mostVotedId = playerId;
    }
  });
 
  se (mostVotedId === room.gameData.impostorId) {
    room.gameData.winnerId = 'crew';
    room.gameData.winReason = 'vote_correct';
  } outro {
    room.gameData.winnerId = 'impostor';
    room.gameData.winReason = 'vote_wrong';
  }
 
  status.da.quarto = 'conclu√≠do';
 
  broadcastToRoom(room.code, { type: 'game-end', room: getRoomForClient(room) });
}
 
// Limpeza peri√≥dica
setInterval(() => {
  const now = Date.now();
  const idade m√°xima = 1000 * 60 * 60 * 2; // 2 horas
 
  artistRooms.forEach((room, code) => {
    const createdAt = new Date(room.createdAt).getTime();
    se (agora - criadoEm > idadeM√°xima) {
      se (room.roundTimer) {
        clearInterval(room.roundTimer);
      }
      artistRooms.delete(c√≥digo);
      roomConnections.delete(c√≥digo);
      console.log(`[Artista] Sala ${code} exclu√≠da (expirada)`);
    }
  });
}, 1000 * 60 * 30);
Agora preciso atualizar o cliente para usar o mesmo padr√£o de mensagens ( join-roomem vez de join):

Preciso atualizar o armazenamento para usar os mesmos tipos de mensagem do servidor:


/workspaces/tikjogos2/client/src/lib/impostorArtistaStore.ts

+ 16
- 6
    const ws = new WebSocket(wsUrl);
 
    ws.onopen = () => {
      definir({ isConnecting: false });
      definir({ isConnecting: false, ws });
      // Usar join-room igual ao jogo original
      ws.send(JSON.stringify({
        tipo: 'entrar',
        C√≥digo da sala: c√≥digo,
        tipo: 'entrar na sala',
        roomCode: code.toUpperCase(),
        playerId: user.uid,
        playerName: user.name,
      }));
...
    };
 
    ws.onclose = () => {
      definir({ isConnecting: false });
      get().addNotification({ type: 'warning', message: 'Conex√£o perdida' });
      definir({ isConnecting: false, ws: null });
    };
 
    ws.onerror = (erro) => {
...
      definir({ isConnecting: false });
    };
 
    conjunto({ ws });
    // O respondedor envia pings
    const pingInterval = setInterval(() => {
      se (ws.readyState === WebSocket.OPEN) {
        // Ping √© enviado pelo servidor, cliente responde com pong
      }
    }, 5000);
 
    ws.onclose = () => {
      clearInterval(pingInterval);
      definir({ isConnecting: false, ws: null });
    };
  },
 
  atualizarSala: (sala: SalaDoArtista) => {
Agora preciso atualizar o gerenciador de mensagens para usar os tipos corretos:

√â necess√°rio atualizar os tipos de mensagem para usar hifen em vez de sublinhado (igual ao servidor):
